const test = require('blue-tape');
const { conv2 } = require('../../../src/matlab/conv2');
const { roundTo } = require('../../helpers/round');

test('should generate the same matrix with a kernel of 1', (t) => {
	const A = [
		[0.4366211, 0.9054124, 0.5962102],
		[0.6371818, 0.1158246, 0.6470448],
		[0.0063498, 0.2951452, 0.6623801]
	];
	const B = [
		[0, 0, 0],
		[0, 1, 0],
		[0, 0, 0]
	];
	const out = conv2(A, B, 'same');

	t.deepEqual(out, A);
	t.end();
});

test('should offset and divide the matrix with a moved kernel of 0.5', (t) => {
	const A = [
		[0.4366211, 0.9054124, 0.5962102],
		[0.6371818, 0.1158246, 0.6470448],
		[0.0063498, 0.2951452, 0.6623801]
	];
	const B = [
		[0, 0.5, 0],
		[0, 0, 0],
		[0, 0, 0]
	];
	const C = [
		[0.3185909, 0.0579123, 0.3235224],
		[0.0031749, 0.1475726, 0.33119005],
		[0.0000000, 0.0000000, 0.0000000]
	];
	const out = conv2(A, B, 'same');

	t.deepEqual(out, C);
	t.end();
});

test('should generate the convolution of "same" values like Matlab', (t) => {
	const A = [
		[0.4366211, 0.9054124, 0.5962102],
		[0.6371818, 0.1158246, 0.6470448],
		[0.0063498, 0.2951452, 0.6623801]
	];
	const B = [
		[0.180854, 0.650212, 0.848889, 0.661308],
		[0.098090, 0.877106, 0.662927, 0.242400],
		[0.625190, 0.318765, 0.920264, 0.668719],
		[0.873018, 0.264735, 0.082795, 0.516670]
	];
	const C = [
		[1.9677205305226, 2.7994413827229, 2.3686256720085],
		[2.1522248148631005, 1.9755068456836002, 1.7007216437643],
		[1.1623389165626001, 0.9970991503065001, 0.9203489336432]
	];
	const out = conv2(A, B, 'same');

	t.deepEqual(out, C);
	t.end();
});

test('should generate "full" convolution by default', (t) => {
	const A = [
		[0.4366211, 0.9054124, 0.5962102],
		[0.6371818, 0.1158246, 0.6470448],
		[0.0063498, 0.2951452, 0.6623801]
	];
	const B = [
		[0.180854, 0.650212, 0.848889, 0.661308],
		[0.098090, 0.877106, 0.662927, 0.242400],
		[0.625190, 0.318765, 0.920264, 0.668719],
		[0.873018, 0.264735, 0.082795, 0.516670]
	];
	const C = [
		[0.07896467241939999, 0.4476437328628, 1.0671798558974999, 1.4449986797848,
			1.1048727438869999, 0.3942785749416],
		[0.1580650409562, 0.9070254836025999, 1.8753006290867003, 2.1694107685774, 1.2405807528194,
			0.5724172550784],
		[0.3366206950002, 1.3329784243407001, 1.9677205305226, 2.7994413827229, 2.3686256720085,
			0.9935780074245999],
		[0.7801606209038, 1.2160740880295, 2.1522248148631005, 1.9755068456836002, 1.7007216437643,
			0.9012960118852],
		[0.5602410121344, 0.45634720605080004, 1.1623389165626001, 0.9970991503065001,
			0.9203489336432, 0.7772547949079],
		[0.0055434896964, 0.25934808651659996, 0.6569307463548001, 0.20307249377349998,
			0.20733443086349998, 0.342231926267]
	];

	const outSame = conv2(A, B, 'full');
	const out = conv2(A, B);

	t.deepEqual(out, C);
	t.deepEqual(out, outSame);
	t.end();
});

test('should generate the convolution of "valid" values', (t) => {
	const A = [
		[0.4366211, 0.9054124, 0.5962102],
		[0.6371818, 0.1158246, 0.6470448],
		[0.0063498, 0.2951452, 0.6623801]
	];
	const B = [
		[0.909911, 0.824447, 0.880526],
		[0.970307, 0.867250, 0.097273],
		[0.075271, 0.940705, 0.281154]
	];
	const out = conv2(A, B, 'valid');

	t.equal(roundTo(out[0][0], 4), 2.6613);
	t.equal(out.length, 1);
	t.equal(out[0].length, 1);
	t.end();
});
